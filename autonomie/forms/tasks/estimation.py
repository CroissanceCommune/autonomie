# -*- coding: utf-8 -*-
# * Authors:
#       * TJEBBES Gaston <g.t@majerti.fr>
#       * Arezki Feth <f.a@majerti.fr>;
#       * Miotte Julien <j.m@majerti.fr>;
import functools
import colander
import deform

from colanderalchemy import SQLAlchemySchemaNode

from autonomie.models.task.estimation import (
    Estimation,
    PaymentLine,
    ESTIMATION_STATES,
    PAYMENTDISPLAYCHOICES,
)
from autonomie.models.task.invoice import (
    get_invoice_years,
    Invoice,
)

from autonomie import forms
from autonomie.forms.company import (
    company_node,
    customer_node,
)
from autonomie.forms.custom_types import AmountType
from autonomie.forms.tasks.lists import (
    PeriodSchema,
    AmountRangeSchema,
)
from autonomie.forms.tasks.task import get_add_edit_task_schema
from autonomie.forms.widgets import CleanMappingWidget

STATUS_OPTIONS = (
    ('all', u"Tous les devis", ),
    ('waiting', u"Devis en cours", ),
    ('signed', u'Devis signé'),
    ('geninv', u"Devis concrétisés (avec facture)", ),
    ('aborted', u"Devis annulés", ),
)


def get_list_schema(is_global=False):
    """
    Return the estimation list schema

    :param bool is_global: Should we include global search fields (CAE wide)
    :returns: The list schema
    :rtype: colander.SchemaNode
    """
    schema = forms.lists.BaseListsSchema().clone()

    del schema['search']

    schema.insert(0, customer_node(is_global))

    if is_global:
        schema.insert(
            0,
            company_node(
                name='company_id',
                missing=colander.drop,
                widget_options={'default': ('', u'Toutes les entreprises')}
            )
        )

    schema.insert(
        0,
        PeriodSchema(
            name='period',
            title="",
            validator=colander.Function(
                forms.range_validator,
                msg=u"La date de début doit précéder la date de début"
            ),
            widget=CleanMappingWidget(),
            missing=colander.drop,
        )
    )
    schema.insert(
        0,
        AmountRangeSchema(
            name='ttc',
            title="",
            validator=colander.Function(
                forms.range_validator,
                msg=u"Le montant de départ doit être inférieur ou égale \
à celui de la fin"
            ),
            widget=CleanMappingWidget(),
            missing=colander.drop,
        )
    )

    schema.insert(0, colander.SchemaNode(
        colander.String(),
        name='status',
        widget=deform.widget.SelectWidget(values=STATUS_OPTIONS),
        validator=colander.OneOf([s[0] for s in STATUS_OPTIONS]),
        default='all',
        missing='all'
    ))
    node = forms.year_select_node(
        name='year',
        query_func=get_invoice_years,
    )
    schema.insert(0, node)

    return schema


@colander.deferred
def deferred_invoice_widget(node, kw):
    """
    Return a select for estimation selection
    """
    query = Invoice.query()
    query = query.filter_by(project_id=kw['request'].context.project_id)
    choices = []
    for invoice in query:
        if invoice.estimation_id is None:
            label = invoice.name
        else:
            label = u"{0} (est déjà rattachée à un devis)".format(invoice.name)
        choices.append((invoice.id, label))
    return deform.widget.CheckboxChoiceWidget(values=choices)


class InvoiceAttachSchema(colander.Schema):
    invoice_ids = colander.SchemaNode(
        colander.Set(),
        widget=deferred_invoice_widget,
        missing=colander.drop,
        title=u"Factures à rattacher à ce devis",
    )


def _customize_paymentline_schema(schema):
    """
    Customize PaymentLine related form schema

    :param obj schema: The schema generated by colanderalchemy
    :rtype: `colander.SQLAlchemySchemaNode`
    """
    customize = functools.partial(forms.customize_field, schema)
    customize("id", widget=deform.widget.HiddenWidget(), missing=colander.drop)
    customize("task_id", missing=colander.required)
    customize("description", validator=forms.textarea_node_validator)
    customize("amount", typ=AmountType(5), missing=colander.required)
    return schema


def _customize_estimation_schema(schema):
    """
    Add form schema customization to the given Estimation edition schema

    :param obj schema: The schema to edit
    """
    customize = functools.partial(forms.customize_field, schema)
    customize(
        "signed_status",
        widget=deform.widget.SelectWidget(values=ESTIMATION_STATES),
        validator=colander.OneOf([i[0] for i in ESTIMATION_STATES])
    )
    customize(
        "deposit",
        validator=colander.Range(
            0,
            100,
            min_err=u"Ce nombre n'est pas compris en 0 et 100",
            max_err=u"Ce nombre n'est pas compris en 0 et 100",
        )
    )
    customize(
        "paymentDisplay",
        widget=deform.widget.SelectWidget(values=PAYMENTDISPLAYCHOICES),
        validator=colander.OneOf([i[0] for i in PAYMENTDISPLAYCHOICES]),
    )
    customize(
        "payment_lines",
        validator=colander.Length(
            min=1, min_err="Au moins un paiement est requis"
        ),
        missing=colander.required
    )

    if 'payment_lines' in schema:
        child_schema = schema['payment_lines'].children[0]
        _customize_paymentline_schema(child_schema)
    return schema


def get_add_edit_paymentline_schema(includes=None, excludes=None):
    """
    Return add edit schema for PaymentLine edition

    :param tuple includes: Field that should be included in the schema
    :param tuple excludes: Field that should be excluded in the schema
    (incompatible with includes option)

    :rtype: `colanderalchemy.SQLAlchemySchemaNode`
    """
    if includes is not None:
        excludes = None

    schema = SQLAlchemySchemaNode(
        PaymentLine, includes=includes, excludes=excludes
    )
    schema = _customize_paymentline_schema(schema)
    return schema


def get_add_edit_estimation_schema(isadmin=False, includes=None, excludes=None,
                                   **kw):
    """
    Return add edit schema for Estimation edition

    :param bool isadmin: Are we asking for an admin schema ?
    :param tuple includes: Field that should be included in the schema
    :param tuple excludes: Field that should be excluded in the schema
    (incompatible with includes option)

    :rtype: `colanderalchemy.SQLAlchemySchemaNode`
    """
    schema = get_add_edit_task_schema(
        Estimation,
        isadmin=isadmin,
        includes=includes,
        excludes=excludes,
        **kw
    )
    schema = _customize_estimation_schema(schema)
    return schema


def validate_estimation(estimation_object, request):
    """
    Globally validate an estimation_object

    :param obj estimation_object: An instance of Estimation
    :param obj request: The pyramid request
    :raises: colander.Invalid

    try:
        validate_estimation(est, self.request)
    except colander.Invalid as err:
        error_messages = err.messages
    """
    schema = get_add_edit_estimation_schema()
    schema = schema.bind(request=request)
    appstruct = estimation_object.__json__(request)
    cstruct = schema.deserialize(appstruct)
    return cstruct
